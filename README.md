# OCA2
Глава 2
 Операторы и циклы
 


Понимание операторов Java

Оператор Java - это специальный символ, который можно применять к набору переменных, значений или литералов,
называемых операндами, и который возвращает результат. В Java доступны три разновидности операторов: унарный, двоичный и троичный. 
Эти типы операторов могут быть применены к одному, двум или трем операндам соответственно.
Для экзамена по ОСА вам необходимо знать конкретное подмножество операторов Java, как их применять и в каком порядке их следует применять.
Операторы Java не обязательно оцениваются слева направо.
Например, следующее выражение Java фактически вычисляется справа налево с учетом конкретных задействованных операторов:
int y = 4;
double x = 3 + 2 * --y;
В этом примере, вы первый уменьшаем yдо 3, а затем умножить полученное значение на 2, и , наконец , добавить 3.
Затем значение будет автоматически увеличено с 9до 9.0и присвоено x. Окончательные значения xи yбудут 9.0и 3, соответственно.
Если вы не следовали этой оценке, не волнуйтесь. К концу этой главы решение подобных проблем должно стать второй натурой.
Если операторы Java не переопределяются скобками, они следуют порядку операций , указанному в таблице 2.1 , уменьшая порядок приоритетов операторов . 
Если два оператора имеют одинаковый уровень приоритета, то Java гарантирует оценку слева направо.
Вы должны знать только тех операторов, которые выделены жирным шрифтом для экзамена ОСА.

Таблица 2.1 Порядок приоритета операторов

оператор	                   Символы и примеры
Пост-унарные операторы	expression++ , expression--
Пре-унарные операторы	++ expression, --expression
Другой унарные операторы	+, -, !
Умножение / Отдел / Modulus	* , / , %
Сложение / Вычитание	+ , -
Операторы смены	≪, ≫, ≫>
Реляционные операторы	< , > , <= , >= , instanceof
Равно / не равно	== , !=
Логические операторы	& , ^ , |
Логические операторы короткого замыкания	&& , ||
Тернарные операторы	boolean expression ? expression1 : expression2
Тернарные операторы	= , += , -= , *=, /=, %=, &=, ^=, !=, ≪=, ≫=, ≫>=


В первой половине этой главы мы обсудим многие операторы в этом списке, а также то, как приоритет оператора определяет, какие операторы должны применяться первыми. Обратите внимание, что вы не будете тестироваться на некоторых операторах, хотя мы рекомендуем вам знать об их существовании.
Работа с двоичными арифметическими операторами
Мы начнем наше обсуждение с бинарных операторов , безусловно, наиболее распространенных операторов в языке Java. Они могут использоваться для выполнения математических операций над переменными, создания логических выражений, а также для выполнения основных назначений переменных. Бинарные операторы обычно объединяются в сложные выражения с более чем двумя переменными; следовательно, приоритет оператора очень важен при оценке выражений.
Арифметические Операторы
Арифметические операторы часто встречаются в ранней математике и включают сложение (+), вычитание (-), умножение (*), деление (/) и модуль (%). Они также включают унарные операторы,++и--, хотя мы рассмотрим их позже в этой главе. Как вы можете иметьзаметил в таблице 2.1 , то мультипликативные операторы ( *, /, %) , имеют более высокий порядок приоритета , чем аддитивные операторы ( +, -). Это означает, что когда вы видите такое выражение:



int x = 2 * 5 + 3 * 4 - 8;
сначала вы оцениваете 2 *5 и 3 * 4, что сводит выражение к следующему:

int x = 10 + 12 - 8;
Затем вы оцениваете оставшиеся члены в порядке слева направо, в результате чего получается значение x1 4. Убедитесь, что вы понимаете, почему результат равен 2, так 4как вы, скорее всего, увидите этот вопрос о приоритетах операторов на экзамене.
Обратите внимание, что перед таблицей 2.1 мы сказали «Если не указано в скобках…» . Это потому, что вы можете явно изменить порядок операций, заключив скобки вокруг разделов, которые вы хотите сначала оценить. Сравните предыдущий пример со следующим, содержащим те же значения и операторы, в том же порядке, но с двумя наборами скобок:

int x = 2 * ((5 + 3) * 4 – 8);
На этот раз вы оцените оператор сложения 10 + 3, который сводит выражение к следующему:
int x = 2 * (8 * 4 – 8);
Вы можете дополнительно уменьшить это выражение, умножив первые два значения в скобках:
int x = 2 * (32 – 8);
Далее вы вычитаете значения в круглых скобках, прежде чем применять термины вне скобок:
int x = 2 * 24;
Наконец, вы должны умножить результат на 2, в результате чего значение 48для x.
Все арифметические операторы могут применяться к любым примитивам Java, кроме booleanи String. Кроме того, только операторы сложения +и + = могут применяться к Stringзначениям, что приводит к Stringобъединению.
Хотя мы уверены, что вы уже видели большинство арифметических операторов, оператор модуля %может быть для вас новым. Модуль, или оператор остатка, является просто остатком, когда два числа разделены. Например, 9делится на 3делит поровну и не имеет остатка; следовательно, остаток, или 9 % 3, есть 0. С другой стороны, 11делится на 3не делится равномерно; следовательно, остаток, или 11 % 3, есть 2.
Обязательно поймите разницу между арифметическим делением и модулем. Для целочисленных значений деление приводит к минимальному значению ближайшего целого числа, которое выполняет операцию, тогда как модуль является значением остатка. Следующие примеры иллюстрируют это различие:
System.out.print(9 / 3);  // Outputs 3
System.out.print(9 % 3);  // Outputs 0
System.out.print(10 / 3);  // Outputs 3
System.out.print(10 % 3);  // Outputs 1
System.out.print(11 / 3);  // Outputs 3
System.out.print(11 % 3);  // Outputs 2
System.out.print(12 / 3);  // Outputs 4
System.out.print(12 % 3);  // Outputs 0
Обратите внимание, что результат деления увеличивается только тогда, когда значение с левой стороны переходит от 9к 12, тогда как значение остатка модуля увеличивается с 1каждым разом, когда левая часть увеличивается до тех пор, пока не обернется до нуля. Для данного делителя y, который находится 3в этих примерах, операция модуля приводит к значению между 0и (y - 1)для положительных дивидендов. Это означает , что результат операции модуля всегда 0, 1или 2.
Операция модуля не ограничивается положительными целочисленными значениями в Java и может также применяться к отрицательным целым числам и целым числам с плавающей точкой. Для данного делителя yи отрицательного дивиденда полученное значение модуля находится между и (-y + 1)и 0. Тем не менее, для экзамена по ОСА вы не обязаны принимать модуль отрицательного целого числа или числа с плавающей запятой.
Числовое продвижение
Теперь, когда вы понимаете основы арифметических операторов, очень важно поговорить о примитивном числовом продвижении , так как Java может поначалу делать то, что вам кажется необычным. Если вы вспомните в главе 1 «Строительные блоки Java», где мы перечислили числовые типы примитивов, каждый примитив имеет длину в битах. Вам не нужно знать точный размер этих типов для экзамена, но вы должны знать, какие из них больше, чем другие. Например, вы должны знать, что a longзанимает больше места, чем a int, что, в свою очередь, занимает больше места, чем a short, и так далее.
Вы должны запомнить определенные правила, которым будет следовать Java при применении операторов к типам данных:
Числовые правила продвижения
1.	Если два значения имеют разные типы данных, Java автоматически преобразует одно из значений в больший из двух типов данных.
2.	Если одно из значений является целым, а другое - с плавающей точкой, Java автоматически преобразует интегральное значение в тип данных значения с плавающей точкой.
3.	Меньшие Типы данных, а именно byte, shortи char, сначала переводятся в intлюбое время, когда они используются с двоичным арифметическим оператором Java, даже если ни один из операндов не является int.
4.	После того, как все продвижение произошло, и операнды имеют тот же тип данных, результирующее значение будет иметь тот же тип данных, что и его продвинутые операнды.
Последние два правила - это те, с которыми у большинства людей возникают проблемы, и те, которые могут сбить вас с толку на экзамене. Для третьего правила обратите внимание, что унарные операторы исключены из этого правила. Например, применение ++к shortзначению приводит к shortзначению. Мы обсудим унарные операторы в следующем разделе.
Давайте рассмотрим несколько примеров в иллюстративных целях:
Какой тип данных x * y?
int x = 1;
long y = 33;
Если мы следуем первому правилу, поскольку одно из значений равно, longа другое равно intи longбольше, чем значение int, то intзначение повышается до a long, и результирующее значение равно long.
Какой тип данных x + y?

double x = 39.21;
float y = 2.1;
Это на самом деле хитрый вопрос, так как этот код не будет компилироваться! Как вы, возможно, помните из главы 1, литералы с плавающей запятой предполагаются double равными, если только после них не добавляется после f, как в . Если бы значение было правильно установлено , то продвижение было бы аналогично последнему примеру, с обоими операндами, переведенными в a , и результатом было бы значение.2. 1f2. 1fdoubledouble
Какой тип данных x / y?

short x = 10;
short y = 3;
В этом случае мы должны применить третье правило, а именно, xи yоба будут повышены intдо операции, что приведет к выводу типа int. Обратите особое внимание на тот факт, что полученный результат не является a short, как мы вернемся к этому примеру в следующем разделе об операторах присваивания.
Какой тип данных x * y / z?
short x = 14;
float y = 13;
double z = 30;
В этом случае мы должны применить все правила. Во-первых, xбудет автоматически повышен intтолько потому, что это shortи используется в арифметической двоичной операции.Повышенное xзначение будет затем автоматически повышено до floatтак, чтобы его можно было умножить y. Результат x * yбудет автоматически преобразован в a double, так что его можно умножить z, что приведет к doubleзначению.
Работа с унарными операторами
По определению, унарный оператор - это оператор, для работы которого требуется ровно один операнд или переменная. Как показано в таблице 2.2 , они часто выполняют простые задачи, такие как увеличение числовой переменной на единицу или отрицание booleanзначения.
Таблица 2.2. Унарные операторы Java
Unary operator	Описание
+	Указывает, что число положительное, хотя в Java предполагается, что числа положительные, если только они не сопровождаются отрицательным унарным оператором.
-	Указывает, что буквенное число отрицательно или отрицает выражение
++	Увеличивает значение на 1
--	Уменьшает значение на 1
!	Инвертирует логическое значение логического типа

Операторы логического дополнения и отрицания
Оператор логического дополнения ! , переворачивает значение booleanвыражения. Например, если значение равно true, оно будет преобразовано в false, и наоборот. Чтобы проиллюстрировать это, сравните результаты следующих утверждений:

boolean x = false;
System.out.println(x);  // false
x = !x;
System.out.println(x);  // true
Аналогично, оператор отрицания , -, изменяет знак числового выражения, как показано в этих утверждениях:

double x = 1.21;
System.out.println(x);  // 1.21
x = -x;
System.out.println(x);  // -1.21
x = -x;
System.out.println(x);  // 1.21

На основании в описании может быть очевидно, что некоторые операторы требуют, чтобы переменная или выражение, на которое они действуют, имели определенный тип. Например, вы не можете применить оператор отрицания -к Boolean выражению и не можете применить оператор логического дополнения !к числовому выражению. Будьте осторожны с вопросами на экзамене, которые пытаются это сделать, так как они приведут к сбою кода. Например, ни одна из следующих строк кода не будет компилироваться:
int x = !5;  // DOES NOT COMPILE
boolean y = -true;  // DOES NOT COMPILE
boolean z = !0;  // DOES NOT COMPILE
Первое утверждение не будет компилироваться из-за того факта, что в Java вы не можете выполнить логическую инверсию числового значения. Второе утверждение не компилируется, потому что вы не можете численно отрицать boolean значение; вам нужно использовать логический обратный оператор. Наконец, последний оператор не компилируется, потому что вы не можете получить логическое дополнение числового значения и не можете назначить целое число booleanпеременной.
Следите за вопросами на экзамене, которые используют оператор логического дополнения или числовые значения с Boolean выражениями или переменными. В отличие от некоторых других языков программирования, в Java   1 и true никак не связаны, так же как 0 и falseне связаны.
Операторы инкремента и декремента
Операторы увеличения и уменьшения ++и --, соответственно, могут применяться к числовым операндам и иметь более высокий порядок или приоритет по сравнению с бинарными операторами. Другими словами, они часто применяются в первую очередь к выражению.
Операторы инкремента и декремента требуют особой осторожности, потому что порядок, к которому они применяются к связанному операнду, может иметь значение при обработке выражения. Если оператор находится перед операндом, называют пре-инкремент оператора и оператора предварительно декремента , то оператор сначала применяется и возвращаемое значение является новое значение выражения. В качестве альтернативы, если оператор помещаются после операнда, упоминается как пост-инкремент оператор и оператор поста-декремент , то исходное значение выражения возвращается, с оператором применяется после того , как значение возвращается.
 следующий фрагмент кода иллюстрирует это различие:
int counter = 0;
System.out.println(counter);  // Outputs 0
System.out.println(++counter);  // Outputs 1
System.out.println(counter); // Outputs 1
System.out.println(counter--);  // Outputs 1
System.out.println(counter);  // Outputs 0
Первый оператор предварительного увеличения обновляет значение counterи выводит новое значение 1. Следующий оператор после декремента также обновляет значение, counterно выводит значение до того, как произойдет декремент.
Одна из распространенных практик на сертификационном экзамене, хотя и не так часто встречающаяся в реальном мире, заключается в применении нескольких операторов увеличения или уменьшения к одной переменной в одной строке:

int x = 3;
int y = ++x * 5 / x-- + --x;
System.out.println("x is " + x);
System.out.println("y is " + y);
Этот более сложный, чем предыдущий пример, потому что xон изменяется три раза в одной строке. Каждый раз, когда оно изменяется, когда выражение перемещается слева направо, значение xизменяется, и переменной присваиваются различные значения. Как вы помните из нашего обсуждения приоритетности операторов, порядок работы играет важную роль в оценке этого примера.
Итак, как вы читаете этот код? Сначала xувеличивается и возвращается к выражению, которое умножается на 5. Мы можем упростить это:

int y = 4 * 5 / x-- + --x;  // x assigned value of 4
Далее, xуменьшается, но оригинальное значение 4используется в выражении, что приводит к этому:

int y = 4 * 5 / 4 + --x;  // x assigned value of 3
При окончательном присваивании xзначение уменьшается до 2, и, поскольку это оператор предварительного увеличения, это значение возвращается в выражение:

int y = 4 * 5 / 4 + 2;  // x assigned value of 2
Наконец, мы оцениваем кратное и деление слева направо и заканчиваем сложением. Результат затем печатается:

x is 2
y is 7
Использование дополнительных бинарных операторов
Хорошо Теперь расширим наше обсуждение бинарных операторов, включив в него все другие бинарные операторы, которые вам нужно знать для экзамена. Это включает в себя операторы, которые выполняют назначения, те, которые сравнивают арифметические значения и возвращают booleanрезультаты, и те, которые сравнивают booleanи объектные значения и возвращают booleanрезультаты.
Операторы присваивания
Оператор присваивания является бинарным оператором , который модифицирует, или правопреемников, переменный на левой стороне оператора, в результате значения на правой стороне уравнения. Самый простой оператор присваивания - это =присваивание, которое вы уже видели:

int x = 1;
Это утверждение присваивает xзначение 1.
Java будет автоматически продвигаться от меньших к большим типам данных, как мы видели в предыдущем разделе об арифметических операторах, но она сгенерирует исключение компилятора, если обнаружит, что вы пытаетесь преобразовать данные больших или меньших типов.
Давайте вернемся к некоторым примерам, подобным тому, что вы видели в главе 1, чтобы показать, как приведение может решить эти проблемы:

int x = 1.0;  // DOES NOT COMPILE
short y = 1921222;  // DOES NOT COMPILE
int z = 9f;  // DOES NOT COMPILE
long t = 192301398193810323;  // DOES NOT COMPILE
Первый оператор не компилируется, потому что вы пытаетесь присвоить значение типа double целочисленному значению. Хотя значение является математическим целым числом, добавляя , вы указываете компилятору обрабатывать его как . Второе утверждение не компилируется, потому что литеральное значение находится за пределами диапазона, и компилятор обнаруживает это. Третий оператор не компилируется из-за добавления к концу числа, который указывает компилятору обрабатывать число как значение с плавающей запятой. Наконец, последний оператор не компилируется, потому что Java интерпретирует литерал как a и замечает, что значение больше, чем позволяет. Литерал должен был бы иметь постфикс, чтобы считаться a .1. 0. 0double1921222shortfintintLlong
Кастинг Примитивных Ценностей
Мы можем исправить примеры из предыдущего раздела, приведя результаты к меньшему типу данных. Преобразование примитивов требуется каждый раз, когда вы переходите от числового типа данных большего размера к числовому типу данных меньшего размера или преобразовываете число с плавающей запятой в целое значение.

int x = (int)1.0;
short y = (short)1921222;  // Stored as 20678
int z = (int)9l;
long t = 192301398193810323L;
Переполнение и потеря 
выражения в предыдущем примере теперь компилируются, хотя это и требует затрат. Второе значение, 1,921,222слишком большое, чтобы быть сохраненным как short, поэтому происходит переполнение чисел, и оно становится 20,678. Переполнение - это когда число настолько велико, что оно больше не помещается в тип данных, поэтому система «оборачивается» до следующего наименьшего значения и отсчитывает оттуда. Существует также аналогичный недостаток , когда число слишком мало, чтобы соответствовать типу данных.
Это выходит за рамки экзамена, но нужно соблюдать осторожность в своем собственном коде. Например, следующий оператор выводит отрицательное число:

System.out.print(2147483647+1);  // -2147483648
Поскольку 2147483647это максимальное intзначение, добавление к нему любого строго положительного значения приведет к переносу на следующее отрицательное число.
Давайте на минуту вернемся к одному из наших предыдущих примеров:

short x = 10;
short y = 3;
short z = x * y;  // DOES NOT COMPILE

Исходя из всего, что вы узнали до сих пор, можете ли вы понять, почему последняя строка этого утверждения не скомпилируется? Если вы помните, shortзначения автоматически повышаются intпри применении любого арифметического оператора, а результирующее значение имеет тип int. Попытка установить shortпеременную в intрезультате приводит к ошибке компилятора, поскольку Java считает, что вы пытаетесь неявно преобразовать больший тип данных в меньший.
В некоторых случаях вы можете изменить поведение компилятора по умолчанию. Например, в предыдущем примере мы знаем результат 10 * 3is 30, который легко помещается в shortпеременную. Если вам нужен результат, чтобы быть short, тем не менее, вы можете переопределить это поведение, приведя результат умножения:
short x = 10;
short y = 3;
short z = (short)(x * y);
Выполняя это явное приведение большего значения к меньшему типу данных, вы указываете компилятору игнорировать его поведение по умолчанию. Другими словами, вы сообщаете компилятору о том, что вы предприняли дополнительные шаги, чтобы предотвратить переполнение или недополнение. Также возможно, что в вашем конкретном приложении и сценарии переполнение или недополнение приведет к приемлемым значениям.
Составные операторы присваивания
Помимо простой оператор присваивания =, есть также многочисленные составные операторы присваивания . Для экзамена требуются только два составных оператора, перечисленных в таблице 2.1 , +=и -=. Сложные операторы - это на самом деле просто прославленные формы простого оператора присваивания со встроенной арифметической или логической операцией, которая применяет левую и правую части оператора и сохраняет полученное значение в переменной в левой части заявление. Например, следующие два оператора после объявления xи z эквивалентны:

int x = 2, z = 3;
x = x * z;  // Simple assignment operator
x *= z;  // Compound assignment operator
Левая часть составного оператора может применяться только к переменной, которая уже определена и не может использоваться для объявления новой переменной. В предыдущем примере, если xон еще не был определен, выражение x *= zне будет компилироваться.
Составные операторы полезны не только для краткости - они также могут избавить нас от необходимости явного приведения значения. Например, рассмотрим следующий пример, в котором последняя строка не будет компилироваться из-за того, что результат повышен до a longи назначен intпеременной:


long x = 10;
int y = 5;
y = y * x;  // DOES NOT COMPILE
Основываясь на последних двух разделах, вы сможете найти проблему в последней строке. Эта последняя строка может быть исправлена с явным приведением к (int), но есть лучший способ, используя составной оператор присваивания:
long x = 10;
int y = 5;
y *= x;
Составной оператор сначала xприводит к a long, применяет умножение двух longзначений, а затем приводит результат к int. В отличие от предыдущего примера, в котором компилятор вызвал исключение, в этом примере мы видим, что компилятор автоматически приведёт полученное значение к типу данных значения в левой части составного оператора.
И последнее, что нужно знать об операторе присваивания, - это то, что результатом присваивания является выражение само по себе, равное значению присваивания. Например, следующий фрагмент кода вполне допустим, если не немного странно выглядит:

long x = 5;
long y = (x=3);
System.out.println(x); // Outputs 3
System.out.println(y); // Also, outputs 3
значение переменной xкак 3. Во-вторых, он возвращает значение присваивания, которое также 3. Создатели экзаменов любят вставлять оператор присваивания =в середине выражения и использовать значение присваивания как часть более сложного выражения.
Операторы отношений
Теперь перейдем к реляционным операторам , которые сравнивают два выражения и возвращают booleanзначение. Первые четыре реляционных оператора (см. Таблицу 2.3 ) применяются только к числовым примитивным типам данных. Если два числовых операнда не относятся к одному и тому же типу данных, меньший операнд продвигается так, как обсуждалось ранее.
Таблица 2.3 Реляционные операторы
<	Строго меньше чем
<=	Меньше или равно
>	Строго больше чем
>=	Больше или равно

Давайте посмотрим на примеры этих операторов в действии:
int x = 10, y = 20, z = 10;
System.out.println(x < y);  // Outputs true
System.out.println(x <= y);  // Outputs true
System.out.println(x >= z);  // Outputs true
System.out.println(x > z);  // Outputs false
Обратите внимание, что выходные данные последнего примера false, потому что, хотя xи zимеют одинаковое значение, xне строго больше, чем z.
Пятый реляционный оператор ( Таблица 2.4 ) применяется к объектным ссылкам и классам или интерфейсам.
Таблица 2.4 Реляционныйinstanceofоператор

a instanceof b	Истинно, если ссылка, на которую указывает ссылка, является экземпляром класса, подкласса или класса, который реализует определенный интерфейс, как указано в b
instanceofОператор, в то время как полезно для определения произвольный объект является ли членом определенного класса или интерфейса, выходит за рамки для экзамена ОСА.
Логические Операторы
Если Вы изучали информатику, возможно, вы уже сталкивались с логическими операторами. Если нет, не нужно паниковать - мы подробно расскажем о них в этом разделе.
Эти логические операторы , ( &), ( |), и ( ^), могут быть применены к обоим числовых и booleanтипов данных. Когда они применяются к booleanтипам данных, они называются логическими операторами . Кроме того, когда они применяются к числовым типам данных, они называются побитовыми операторами , поскольку они выполняют побитовые сравнения битов, составляющих число. Однако для экзамена вам не нужно ничего знать о числовых побитовых сравнениях, поэтому мы оставим этот образовательный аспект другим книгам.
Вы должны ознакомиться с таблицами истинности на рисунке 2.1 , где xи yпредполагается, что это booleanтипы данных.
Рисунок 2.1 Логические истинные таблицы для&,|и^
Вот несколько советов, которые помогут запомнить эту таблицу:
•	И верно только если оба операнда верны.
•	Включающее ИЛИ является ложным, только если оба операнда ложны.
•	Исключительное ИЛИ верно только в том случае, если операнды различны.
Наконец, мы приводим условные операторы, &&и ||, которые часто называют операторами короткого замыкания. Операторы короткого замыкания почти идентичны логическим операторам &и |, соответственно, за исключением того, что правая часть выражения может никогда не оцениваться, если конечный результат может быть определен левой частью выражения. Например, рассмотрим следующее утверждение:
boolean x = true || (y < 4);
Ссылаясь на таблицы истинности, значение xможет быть ложным, только если обе стороны выражения ложны. Поскольку мы знаем, что левая часть истинна, нет необходимости оценивать правую часть, поскольку никакое значение yникогда не будет иметь значения, xотличного от истинного. Это может помочь вам проиллюстрировать эту концепцию, выполнив предыдущую строку кода для различных значений y.
 более распространенный пример использования операторов короткого замыкания - проверка nullобъектов перед выполнением операции, например:

if(x != null && x.getValue() < 5) { 
 // Do something
}
В этом примере, если xбыло null, то короткое замыкание предотвращает NullPointerExceptionвыброс, так как оценка x.getValue() < 5никогда не достигается. С другой стороны , если бы мы использовали логический &, то обе стороны всегда будут оценены и когда xбыло nullэто будет сгенерировано исключение:

if(x != null & x.getValue() < 5) { // Throws an exception if x is null 
 // Do something
}

Остерегайтесь поведения короткого замыкания на экзамене, так как известно, что вопросы изменяют переменную в правой части выражения, которая может никогда не быть достигнута. Например, каков вывод следующего кода?
int x = 6;
boolean y = (x >= 6) || (++x <= 7);
System.out.println(x);
Потому что x >= 6это true, оператор инкремента на правой стороне выражения никогда не оценивается, поэтому выход 6.
Операторы равенства
Определение равенства в Java может быть нетривиальной задачей, поскольку есть семантическая разница между «два объекта одинаковы» и «два объекта эквивалентны». Это еще более осложняется тем, что для числовых и booleanпримитивов такого различия нет.
Давайте начнем с основ, оператора равенства,== а не оператора равенства!= . Как и реляционные операторы, они сравнивают два операнда и возвращают booleanзначение о том, равны или нет выражения или значения, соответственно.
Операторы равенства используются в одном из трех сценариев:
1.	Сравнение двух числовых примитивных типов. Если числовые значения относятся к разным типам данных, значения автоматически повышаются, как описано ранее. Например, 5 == 5.00возвращает, trueпоскольку левая сторона повышена до double.
2.	Сравнивая два booleanзначения.
3.	Сравнивая два объекта, в том числе nullи Stringзначения. 
Сравнения на равенство ограничены этими тремя случаями, поэтому вы не можете смешивать и сопоставлять типы. Например, каждое из следующего может привести к ошибке компилятора:

boolean x = true == 3;  // DOES NOT COMPILE
boolean y = false != "Giraffe";  // DOES NOT COMPILE
boolean z = 3 == "Kangaroo";  // DOES NOT COMPILE
Обратите особое внимание на типы данных, когда вы видите оператор равенства на экзамене. Создатели экзаменов также имеют привычку смешивать операторы присваивания и операторы равенства, как показано в следующем фрагменте:

boolean y = false;
boolean x = (y = true);
System.out.println(x);  // Outputs true
На первый взгляд, вы можете подумать, что вывод должен быть false, и если бы выражение было (y == true), то вы были бы правы. В этом примере, однако, выражение присваивает значение trueдля y, и, как вы видели в разделе об операторах присваивания, само присваивание имеет значение присваивания. Поэтому на выходе будет true.
Для сравнения объектов оператор равенства применяется к ссылкам на объекты, а не к объектам, на которые они указывают. Две ссылки равны, если и только если они указывают на один и тот же объект или обе указывают на null. Давайте посмотрим на некоторые примеры:

File x = new File("myFile.txt");
File y = new File("myFile.txt");
File z = x;
System.out.println(x == y);  // Outputs false
System.out.println(x == z);  // Outputs true
Несмотря на то, что все переменные указывают на одну и ту же информацию файла, только две xи zравны с точки зрения ==. В этом примере, а также во время экзамена по ОСА вам могут быть представлены незнакомые имена классов, такие как File. Много раз вы можете ответить на вопросы об этих классах, не зная конкретных деталей этих классов. В частности, вы должны быть в состоянии ответить на вопросы, которые указывают xи yявляются двумя отдельными и разными объектами, даже если вы не знаете типы данных этих объектов.
В главе 3 «Базовые API-интерфейсы Java» мы продолжим обсуждение равенства объектов, представляя, что означает, что два разных объекта эквивалентны. Мы также рассмотрим Stringравенство и покажем, как это может быть нетривиальной темой.
Понимание утверждений Java
Операторы Java позволяют создавать множество сложных выражений, но они ограничены в способе управления потоком программ. Например, представьте, что вы хотите, чтобы часть кода выполнялась только при определенных условиях, которые нельзя оценить дово время выполнения. Или предположим, что вы хотите, чтобы определенный сегмент кода повторялся один раз для каждого элемента в каком-либо списке.
Как вы помните из главы 1, Java заявление является полной единицей выполнения в Java, завершается точкой с запятой ( ;). В оставшейся части главы мы познакомим вас с различными операторами потока управления Java. Операторы потока управления разбивают поток выполнения, используя принятие решений, циклы и переходы, позволяя приложению выборочно выполнять определенные сегменты кода.
Эти операторы могут применяться к отдельным выражениям, а также к блоку кода Java. Как описано в предыдущей главе, блок кода в Java представляет собой группу из нуля или более операторов между сбалансированными скобками, ( {}), и может использоваться везде, где разрешен один оператор.
Если-то заявление
Часто мы хотим выполнить блок кода только при определенных обстоятельствах. Оператор if-then , как показано на рисунке 2.2 , выполняет это, позволяя нашему приложению выполнять определенный блок кода тогда и только тогда, когда booleanвыражение вычисляется trueво время выполнения.
Рисунок 2.2 Структураif-thenзаявления
Например, представьте, что у нас есть функция, которая использует час дня, целочисленное значение от 0до 23, для отображения сообщения пользователю:
if(hourOfDay < 11)    
  System.out.println("Good Morning");
Если время суток меньше 11, то сообщение будет отображаться. Теперь предположим, что мы также хотели увеличить какое-то значение morningGreetingCount, каждый раз, когда приветствие печатается. Мы могли бы написать if-thenоператор дважды, но, к счастью, Java предлагает нам более естественный подход с использованием блока:

if(hourOfDay < 11) {
  System.out.println("Good Morning"); 
 morningGreetingCount++;}
Блок позволяет выполнять несколько операторов на основе if-thenоценки. Обратите внимание, что в первом операторе не было блока вокруг секции print, но он мог легко иметь. Для удобства чтения считается хорошей практикой кодирования размещать блоки вокруг компонента выполнения if-thenоператоров, а также многих других операторов потока управления, хотя это не требуется.
Смотреть отступы и брекеты
Авторы экзаменов постараются сбить вас с толку - это if-thenзаявления без скобок ( {}). Например, взгляните на эту слегка измененную форму нашего примера:

if(hourOfDay < 11) 
 System.out.println("Good Morning");
  morningGreetingCount++;
Исходя из отступа, вы можете быть склонны думать, что переменная morningGreetingCountбудет увеличиваться только в том случае, если hourOfDayона меньше 11, но этот код не тот, что делает. Он будет выполнять оператор print только в том случае, если условие выполнено, но он всегда будет выполнять операцию приращения.
Помните, что в Java, в отличие от некоторых других языков программирования, вкладки являются просто пробелами и не оцениваются как часть выполнения. Когда вы видите оператор потока управления в вопросе, обязательно проследите открытые и закрытые фигурные скобки блока и игнорируйте любые отступы, с которыми вы можете столкнуться.
Если-то-иначе заявление
Давайте немного расширим наш пример. Что если мы хотим отобразить другое сообщение, если это 11 часов утра или позже? Можем ли мы сделать это, используя только те инструменты, которые у нас есть? Конечно, мы можем!

if(hourOfDay < 11) {  
System.out.println("Good Morning");
}
if(hourOfDay >= 11) { 
 System.out.println("Good Afternoon");
}
Это кажется немного избыточным, поскольку мы выполняем оценку hourOfDayдважды. Это также расточительно, потому что в некоторых случаях стоимость booleanвыражения, которое мы оцениваем, может быть вычислительно дорогой. К счастью, Java предлагает нам более полезный подход в форме оператора if-then-else , как показано на рисунке 2.3 .
Рисунок 2.3 . Структураif-then-elseвыписки
Давайте вернемся к этому примеру:

if(hourOfDay < 11) { 
 System.out.println("Good Morning");
} else { 
 System.out.println("Good Afternoon");
}
Сейчас же наш код действительно разветвляется между одним из двух возможных вариантов, причем booleanоценка происходит только один раз. elseОператор принимает заявление или блок инструкций, в том же порядке , как ifзаявление делает. Таким образом, мы можем добавить дополнительные if-thenоператоры в elseблок, чтобы получить более тонкий пример:

if(hourOfDay < 11) {  
System.out.println("Good Morning");
} else if(hourOfDay < 15) {  
System.out.println("Good Afternoon");
} else { 
 System.out.println("Good Evening");
}
В этом примере процесс Java продолжит выполнение до тех пор, пока не встретит if-thenоператор, который выполняет оценку true. Если ни одно из первых двух выражений не выполнено true, он выполнит окончательный код elseблока. Одна вещь, которую нужно иметь в виду при создании сложных if-then-elseутвержденийэтот порядок важен Например, посмотрите, что произойдет, если мы изменим порядок предыдущего фрагмента кода следующим образом:

if(hourOfDay < 15) { 
 System.out.println("Good Afternoon");
} 
else if(hourOfDay < 11) {
  System.out.println("Good Morning");  // UNREACHABLE CODE
} else {  
System.out.println("Good Evening");}
Для часов дня менее 11 этот код ведет себя совсем иначе, чем предыдущий набор кода. Посмотрите, сможете ли вы определить, почему второй блок никогда не может быть выполнен независимо от значения hourOfDay.
Если значение меньше чем 11, то оно также должно быть меньше, чем 15по определению. Следовательно, если вторая ветвь в примере может быть достигнута, первая ветвь также может быть достигнута. Поскольку выполнение каждой ветви является взаимоисключающим в этом примере, то есть может быть выполнена только одна ветвь, если выполняется первая ветвь, то вторая не может быть выполнена. Следовательно, вторая ветвь никогда не будет выполнена, и код считается недостижимым.
Проверка выражения if в логическом выражении
Еще одно распространенное место, которое экзамен может попытаться сбить вас с пути, - предоставить код, в котором booleanвыражение внутри if-thenоператора на самом деле не является booleanвыражением. Например, взгляните на следующие строки кода:
int x = 1;
if(x) {  // DOES NOT COMPILE
  …
}
Это утверждение может быть допустимым в некоторых других языках программирования и сценариях, но не в Java, где 0и 1не считаются booleanзначениями. Кроме того, будьте осторожны с использованием операторов присваивания, как если бы они были ==операторами равенства в if-thenвыражениях:

int x = 1;
if(x = 5) {  // DOES NOT COMPILE 
 …
}
Троичный оператор
Сейчас же что мы обсудили if-then-elseутверждения, мы можем кратко вернуться к нашему обсуждению операторов и представить последний оператор, который вам нужно выучить для экзамена. Условный оператор , ? : иначе известный как троичный оператор , является единственным оператором, который принимает три операнда и имеет вид:

booleanExpression ? expression1 : expression2
Первый операнд должен быть booleanвыражением, а второй и третий могут быть любым выражением, которое возвращает значение. Тернарная операция на самом деле является сжатой формой if-then-elseоператора, который возвращает значение. Например, следующие два фрагмента кода эквивалентны:

int y = 10;
final int x;
if(y > 5) {
  x = 2 * y;
} else { 
 x = 3 * y;
}
Сравните предыдущий фрагмент кода со следующим эквивалентным фрагментом кода троичного оператора:
int y = 10;
int x = (y > 5) ? (2 * y) : (3 * y);
Обратите внимание, что для удобства чтения часто полезно добавлять круглые скобки вокруг выражений в троичных операциях, хотя это, безусловно, не требуется.
Не требуется, чтобы второе и третье выражения в троичных операциях имели одинаковые типы данных, хотя они могут вступать в действие при объединении с оператором присваивания. Сравните следующие два утверждения:

System.out.println((y > 5) ? 21 : "Zebra");
int animal = (y < 91) ? 9 : "Horse";  // DOES NOT COMPILE
Оба выражения оценивают одинаковые booleanзначения и возвращают a intи a String, хотя компилируется только первая строка. The System.out.println()не заботится о том, что операторы имеют совершенно разные типы, потому что они могут преобразовывать оба в String. С другой стороны, компилятор знает, что он "Horse"имеет неправильный тип данных и не может быть назначен на int; следовательно, он не позволит скомпилировать код.
Оценка троичной экспрессии
В виде в Java 7 только одно из правых выражений тернарного оператора будет оцениваться во время выполнения. Аналогично операторам короткого замыкания, если одно из двух правых выражений в троичном операторе имеет побочный эффект, оно может не применяться во время выполнения. Давайте проиллюстрируем этот принцип на следующем примере:

int y = 1;
int z = 1;
final int x = y<10 ? y++ : z++;
System.out.println(y+","+z); // Outputs 2,1
Обратите внимание, что, поскольку левое booleanвыражение было true, только yувеличилось. Сравните предыдущий пример со следующей модификацией:

int y = 1;
int z = 1;
final int x = y>=10 ? y++ : z++;
System.out.println(y+","+z); // Outputs 1,2
Теперь, когда левое booleanвыражение оценивается как false, zбыло увеличено только значение . Таким образом, мы видим, как выражения в тройном операторе могут не применяться, если конкретное выражение не используется.
Для экзамена, будьте осторожны с любым вопросом, который включает в себя троичное выражение, в котором переменная изменяется в одном из выражений в правой части.


Переключатель Заявление
The switch Statement
Теперь мы расширим наше обсуждение if-then-elseзаявлений, обсудив switchзаявление. Переключатель заявление , как показано на рисунке 2.4 , представляет собой сложную структуру принятия решений , в которых одно значение вычисляется и поток перенаправляется к первой совпадающей ветви, известный как сазе . Если не найдено такого caseоператора, который соответствует значению, будет вызван необязательный оператор по умолчанию . Если такая defaultопция недоступна, весь switchоператор будет пропущен.
Рисунок 2.4 Структураswitchзаявления
Поддерживаемые типы данных
Как показано на рисунке 2.4 , switchоператор имеет целевую переменную, которая не оценивается до времени выполнения. До Java 5.0, эта переменная может быть только intзначения или те значения , которые можно было бы содействовать , чтобы int, в частности byte, short, char, или int. Когда enumбыл добавлен в Java 5.0, поддержка была добавлена в switchоператоры для поддержки enumзначений. В Java 7, switchзаявлениябыли дополнительно обновлены, чтобы позволить сопоставление по Stringзначениям. Наконец, switchоператор также поддерживает любого из примитивных числовых классов - оболочек, такие как Byte, Short, Character, или Integer.
Типы данных, поддерживаемые switchоператорами, включают следующее:
int а также Integer
byte а также Byte
short а также Short
char а также Character
int а также Integer
String
enum ценности
Для экзамена мы рекомендуем запомнить этот список. Обратите внимание, что booleanи longи связанные с ними классы-оболочки не поддерживаются switchоператорами.
Значения констант во время компиляции
Значения в каждом caseоператоре должны быть значениями констант времени компиляции того же типа данных, что и switchзначение. Это означает, что вы можете использовать только литералы, enumконстанты или finalконстантыпеременные одного и того же типа данных. Под finalконстантой мы подразумеваем, что переменная должна быть помечена finalмодификатором и инициализирована литеральным значением в том же выражении, в котором она объявлена.
Давайте рассмотрим простой пример с использованием дня недели, с 0воскресеньем, 1понедельником и т. Д.
int dayOfWeek = 5;
switch(dayOfWeek) {  
default:   
 System.out.println("Weekday"); 
 break;    
case 0:  
System.out.println("Sunday"); 
   break;  
case 6:
    System.out.println("Saturday");
  break;}

При значении dayOfWeekв 5этом коде выхода будет:

Weekday
Первое , что вы можете заметить, что есть breakзаявление в конце каждого caseи defaultсекции. Мы breakподробно обсудим операторы, когда будем обсуждать циклы, но сейчас все, что вам нужно знать, - это то, что они завершают switchоператор и возвращают управление потоком в содержащий оператор. Как мы скоро увидим, если вы пропустите breakоператор, поток переходит к следующему процессу caseили defaultавтоматически блокируется.
Еще одна вещь, которую вы можете заметить, это то, что defaultблок находится не в конце switchоператора. Не требуется, чтобы операторы caseили defaultбыли в определенном порядке, если только вы не собираетесь иметь пути, которые достигают нескольких секций switchблока за одно выполнение.
Чтобы проиллюстрировать оба предыдущих пункта, рассмотрим следующий вариант:

int dayOfWeek = 5;switch(dayOfWeek) {
  case 0:  
  System.out.println("Sunday"); 
 default:   
 System.out.println("Weekday");  
case 6:   
 System.out.println("Saturday"); 
 break;
}
Эта код очень похож на предыдущий пример, за исключением того, что два breakоператора были удалены и порядок был изменен. Это означает, что для данного значения dayOfWeek, 5код будет переходить к defaultблоку и затем выполнять все последующие caseоператоры по порядку, пока не найдет breakоператор или не завершит структуру:

Weekday
Saturday
Порядок операторов caseand defaultтеперь важен, так как размещение defaultоператора в конце switchоператора приведет к выводу только одного слова.
Что, если значение dayOfWeekбыло 6в этом примере? Будет ли defaultблок все еще выполняться? Вывод этого примера с dayOfWeekустановленным на 6будет:

Saturday

Даже если defaultблок был перед caseблоком, только caseблок был выполнен. Если вы вспомните определение defaultблока, он будет разветвлен только в том случае, если нет соответствующего caseзначения для switchоператора, независимо от его положения в switchоператоре.
Наконец, если значение dayOfWeekбыло бы 0, все три утверждения были бы выведены:

Sunday


Weekday
Saturday
Обратите внимание, что в этом последнем примере defaultвыполняется, так breakкак в конце предыдущего caseблока не было оператора . Хотя код не будет переходить к defaultоператору, если в операторе есть соответствующее caseзначение switch, он выполнит defaultоператор, если встретит его после caseоператора, для которого нет завершающего breakоператора.
Создатели экзаменов любят  switch примеры, в которых отсутствуют  break утверждения! При оценке switchвысказываний на экзамене всегда учитывайте, что в одном исполнении можно посетить несколько ветвей.
Мы завершаем наше обсуждение switchоператоров, признавая, что все типы данных для caseоператоров должны соответствовать типу данных switchпеременной. Как уже обсуждалось, caseзначение оператора также должно быть литеральной, enumпостоянной или finalпостоянной переменной. Например, учитывая следующее switchутверждение, обратите внимание, какие caseутверждения будут компилироваться, а какие нет:
private int getSortOrder(String firstName, final String lastName) {  
String middleName = "Patricia"; 
 final String suffix = "JR";
  int id = 0; 
 switch(firstName) { 
 1  case "Test":    
  return 52;  
2case middleName:       // DOES NOT COMPILE 
   id = 5;  
    break;
3case suffix:   
 id = 0;     
 break;  
4case lastName:  // DOES NOT COMPILE  
  id = 8;     
 break; 
5 case 5:  // DOES NOT COMPILE 
   id = 7;   
   break;  
6case 'J':  // DOES NOT COMPILE
    id = 10;   
   break; 
7 case java.time.DayOfWeek.SUNDAY:  // DOES NOT COMPILE  
  id=15;     
 break;  }  
  return id;
}
Первый caseоператор компилируется без проблем с использованием Stringлитерала и является хорошим примером того, как returnоператор, такой как breakоператор, может быть использован для switchдосрочного выхода из оператора. Второе caseутверждение не компилируется, потому что middleNameне является finalпеременной, несмотря на наличие известного значения в этой конкретной строке выполнения. Третий caseоператор компилируется без проблем, потому что suffixэто finalпостоянная переменная.
В четвертом caseутверждении, несмотря lastNameна finalэто, оно не является постоянным, поскольку оно передается функции; следовательно, эта строка также не компилируется. Наконец, последние три caseоператора не компилируются, потому что ни у одного из них нет соответствующего типа String; последний является enumзначением.
В то время как заявление
Структура управления повторением, которую мы называем циклом , выполняет оператор кода несколько раз подряд. Используя непостоянные переменные, каждое повторение утверждения может быть различным. Например, оператор, который перебирает список уникальных имен и выводит их, будет сталкиваться с новым именем при каждом выполнении цикла. 
Простейшей такой структурой управления повторением в Java является оператор while , описанный на рисунке 2.5 . Как и все структуры управления повторением, он имеет условие завершения, реализованное в виде booleanвыражения, которое будет продолжаться до тех пор, пока выражение вычисляется true.
Рисунок 2.5 Структураwhileзаявления
Как показано на рисунке 2.5 , whileцикл похож на if-thenоператор в том смысле, что он состоит из booleanвыражения и оператора или блока операторов. Во время выполнения booleanвыражение вычисляется перед каждой итерацией цикла и завершается, если оценка возвращается false. Важно отметить, что whileцикл может завершиться после первой оценки booleanвыражения. Таким образом, блок операторов никогда не может быть выполнен.
Давайте вернемся к нашему примеру с мышью из главы 1 и покажем, что цикл можно использовать для моделирования мыши, поедающей еду:

int roomInBelly = 5;
public void eatCheese(int bitesOfCheese) { 
 while (bitesOfCheese > 0 && roomInBelly > 0) { 
   bitesOfCheese--; 
 roomInBelly--;   
 }  System.out.println(bitesOfCheese+" pieces of cheese left");
}
Этот метод требует количества пищи, в данном случае сыра, и продолжается до тех пор, пока у мыши не останется места в животе или не останется еды. С каждой итерацией цикла мышь «съедает» один кусочек пищи и теряет одно пятно на животе. Используя составной booleanоператор, вы гарантируете, что whileцикл может завершиться для любого из условий.
Бесконечные циклы
Рассматривать следующий сегмент кода:

int x = 2;
int y = 5;
while(x < 10) 
 y++;
Вы можете заметить одну вопиющую проблему с этим утверждением: оно никогда не закончится! booleanВыражение, которое вычисляется перед каждой итерации цикла , не изменяются, так что выражение (x < 10)всегда будет вычисляться true. В результате цикл никогда не заканчивается, создавая то, что обычно называют бесконечным циклом .
Бесконечные циклы - это то, что вы должны знать каждый раз, когда создаете цикл в своем приложении. Вы должны быть абсолютно уверены, что цикл в конце концов прекратится при некоторых условиях. Сначала убедитесь, что переменная цикла изменена. Затем убедитесь, что условие прекращения будет в конечном итоге достигнуто при любых обстоятельствах. Как вы увидите в следующем разделе «Общие сведения о расширенном управлении потоком», цикл может также завершиться при других условиях, таких как breakоператор.
Делать, в то время как заявление
Java также позволяет создавать цикл do- while, который, подобно whileциклу, представляет собой структуру управления повторением с условием завершения и оператором или блоком операторов, как показано на рисунке 2.6 . В отличие от whileцикла, do-whileцикл гарантирует, что оператор или блок будут выполнены хотя бы один раз.
Рисунок 2.6 . Структураdo-whileвыписки
 Основное различие между синтаксической структурой do-whileцикла и whileцикла состоит в том, что do-whileцикл преднамеренно упорядочивает оператор или блок операторов перед условным выражением, чтобы подчеркнуть, что оператор будет выполнен до того, как выражение когда-либо будет оценено. Например, взгляните на вывод следующих операторов:
int x = 0;
do {
  x++;} 
while(false);
System.out.println(x);  // Outputs 1
Java сначала выполнит блок операторов, а затем проверит условие цикла. Несмотря на то, что цикл завершается сразу же, блок операторов все еще выполнялся один раз, и программа выдает a 1.
Когда использовать циклы while и do-while
На практике может быть трудно определить, когда вы должны использовать whileцикл, а когда вы должны использовать do-whileцикл. Короткий ответ: на самом деле это не имеет значения. Любой whileцикл может быть преобразован в do-whileцикл, и наоборот. Например, сравните этот whileцикл:

while(x > 10) { 
 x--;
}
и этот do-whileцикл:

if(x > 10) {
  do { 
   x--;  } 
while(x > 10);
}
Хотя один из циклов, безусловно, легче читать, они функционально эквивалентны. Java рекомендует использовать whileцикл, когда цикл может вообще не выполняться, и do-whileцикл, когда цикл выполняется хотя бы один раз. Но определение того, следует ли вам использовать whileцикл или do-whileцикл на практике, иногда зависит от личных предпочтений и читабельности кода.
Например, хотя первый оператор короче, второй обладает тем преимуществом, что вы можете использовать существующий if-thenоператор и выполнять некоторые другие операции в новой elseветви, как показано в следующем примере:

if(x > 10) { 
 do { 
   x--;  } 
while(x > 10);
} else {
  x++;
}
Для заявления
Сейчас же чтобы вы могли создавать приложения с помощью простых операторов whileи do-whileоператоров, мы расширили наше обсуждение циклов до более сложной структуры управления повторениями, называемой forциклом.
Начиная с Java 5.0, теперь есть два типа forоператоров. Первый называется базовым forциклом, а второй часто называется расширенным forциклом. Для ясности мы будем ссылаться на расширенный forцикл как на for-eachутверждение всей книги.
Основное для заявления
Базовый цикл for имеет те же условные booleanвыражения и оператор или блок операторов, что и другие циклы, которые вы видели, а также два новых раздела: блок инициализации и оператор обновления . Рисунок 2.7 показывает, как эти компоненты расположены.
Рисунок 2.7 Структура основногоforутверждения
Хотя рисунок 2.7 можетНа первый взгляд кажется немного запутанным и почти произвольным, организация компонентов и потока позволяет нам создавать чрезвычайно мощные операторы в очень небольшом пространстве, которые в противном случае заняли бы несколько строк со стандартным whileциклом. Обратите внимание, что каждый раздел разделен точкой с запятой. Разделы инициализации и обновления могут содержать несколько операторов, разделенных запятыми.
Переменные, объявленные в блоке инициализации forцикла, имеют ограниченную область видимости и доступны только внутри forцикла. С осторожностью относитесь к любым экзаменационным вопросам, в которых переменная, объявленная в блоке инициализации forцикла, доступна вне цикла. Альтернативно, переменные, объявленные перед forциклом и которым присвоено значение в блоке инициализации, могут использоваться вне forцикла, поскольку их область действия предшествует forсозданию цикла.
Давайте посмотрим на пример, который печатает числа 0в 9:

for(int i = 0; i < 10; i++) { 
 System.out.print(i + " ");
}
Рисунок 2.7 Структура основногоforутвержденияХотя рисунок 2.7 можетНа первый взгляд кажется немного запутанным и почти произвольным, организация компонентов и потока позволяет нам создавать чрезвычайно мощные операторы в очень небольшом пространстве, которые в противном случае заняли бы несколько строк со стандартным whileциклом. Обратите внимание, что каждый раздел разделен точкой с запятой. Разделы инициализации и обновления могут содержать несколько операторов, разделенных запятыми.Переменные, объявленные в блоке инициализации forцикла, имеют ограниченную область видимости и доступны только внутри forцикла. С осторожностью относитесь к любым экзаменационным вопросам, в которых переменная, объявленная в блоке инициализации forцикла, доступна вне цикла. Альтернативно, переменные, объявленные перед forциклом и которым присвоено значение в блоке инициализации, могут использоваться вне forцикла, поскольку их область действия предшествует forсозданию цикла.Давайте посмотрим на пример, который печатает числа 0в 9:

0 1 2 3 4 5 6 7 8 9
На 10-й итерации цикла значение iдостигает 9и увеличивается 1до достижения 10. На 11-й итерации цикла booleanвыражение вычисляется и после (10 < 10)возврата falseцикл завершается без выполнения тела цикла операторов.
Хотя большинство forциклов, с которыми вы, вероятно, столкнетесь на практике, будут четко определены и аналогичны предыдущему примеру, на экзамене вы можете увидеть ряд вариантов и крайних случаев. Вы должны ознакомиться со следующими пятью примерами: их вариации, вероятно, будут видны на экзамене.
Давайте рассмотрим несколько примеров в иллюстративных целях:
1Создание бесконечного цикла
for( ; ; ) {
  System.out.println("Hello World");}
Хотя этот forцикл может выглядеть так, как будто он выдаст ошибку компилятора, он фактически скомпилируется и будет работать без проблем. Это на самом деле бесконечный цикл, который будет печатать одно и то же утверждение несколько раз. Этот пример подтверждает тот факт, что компоненты forцикла являются необязательными. Следует отметить , что точка с запятой , разделяющие три секции необходимы, так как for( ; )и for( )не компилируется.
2ДобавлениеНесколько условий к  for заявлению

int x = 0;
for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) { 
 System.out.print(y + " ");
}
System.out.print(x);

Этот код демонстрирует три варианта forцикла, которые вы, возможно, не видели. Во-первых, вы можете объявить переменную, как xв этом примере, до начала цикла и использовать ее после завершения. Во-вторых, ваш блок инициализации, booleanвыражение и операторы обновления могут содержать дополнительные переменные, которые могут не ссылаться друг на друга. Например, zопределяется в блоке инициализации и никогда не используется. Наконец, updateоператор может изменять несколько переменных. Этот код напечатает следующее при выполнении:
0 1 2 3 4
Помните об этом примере, когда мы смотрим на следующие три примера, ни один из которых не компилируется.
3Переопределение переменной в блоке инициализации

int x = 0;
for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) {   // DOES NOT COMPILE  
System.out.print(x + " ");
}
Этот пример похож на предыдущий, но не компилируется из-за блока инициализации. Разница заключается в том, что xон повторяется в блоке инициализации после того, как он уже был объявлен перед циклом, что приводит к остановке компилятора из-за дублированного объявления переменной. Мы можем исправить этот цикл, изменив объявление xи yследующим образом:
int x = 0;
long y = 10;
for(y = 0, x = 4; x < 5 && y < 10; x++, y++) { 
 System.out.print(x + " ");
}
Обратите внимание, что этот вариант теперь будет компилироваться, потому что блок инициализации просто присваивает значение xи не объявляет его.
4Использование несовместимых типов данных в блоке инициализации

for(long y = 0, int x = 4; x < 5 && y<10; x++, y++) {   // DOES NOT COMPILE 
 System.out.print(x + " ");
}
Этот пример также очень похож на наш второй пример, но, как и третий, компилироваться не будет, хотя на этот раз по другой причине. Все переменные в блоке инициализации должны быть одного типа. В первом примере yи zбыли оба long, поэтому код компилируется без проблем, но в этом примере они имеют разные типы, поэтому код не будет компилироваться.
5С помощью Переменные цикла вне цикла

for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) {  
System.out.print(y + " ");
}
System.out.print(x);  // DOES NOT COMPILE
Окончательный вариант второго примера не будет компилироваться по причине, отличной от предыдущих примеров. Если вы заметили, xопределяется в блоке инициализации цикла, а затем используется после завершения цикла. Поскольку он xбыл ограничен только циклом, его использование вне цикла вызовет ошибку компилятора.
Для каждого- заявления
Начиная с Java 5.0, разработчики Java получили в распоряжение новый тип усовершенствованного forцикла, специально разработанный для итерации массивов и Collectionобъектов. Этот расширенный forцикл, который для ясности мы будем называть циклом for-each , показан на рисунке 2.8 .
Рисунок 2.8 
Структура аксессуараforзаявления
for-eachДекларация цикла состоит из секции инициализации и объекта для итерации. Правая часть for-eachоператора цикла должна быть встроенным массивом Java или объектом, чей класс реализует java.lang.Iterable, который включает в себя большую часть Collectionsинфраструктуры Java . Левая часть for-eachцикла должна включать объявление для экземпляра переменной, тип которой соответствует типу члена массива или коллекции в правой части инструкции. На каждой итерации цикла именованной переменной в левой части оператора присваивается новое значение из массива или коллекции в правой части оператора.
Для экзамена OCA единственными членами Collectionsструктуры, о которых вам нужно знать, являются Listи ArrayList. В этой главе мы покажем, как перебирать Listобъекты, а в главе 3 мы подробно рассмотрим, как создавать Listобъекты и чем они отличаются от традиционных массивов Java.
Давайте рассмотрим несколько примеров:
Что будет выводить этот код?

final String[] names = new String[3];
names[0] = "Lisa";
names[1] = "Kevin";
names[2] = "Roger";
for(String name : names) { 
 System.out.print(name + ", ");
}

Этот код скомпилирует и напечатает:
Lisa, Kevin, Roger,
Что будет выводить этот код?
java.util.List<String> values = new java.util.ArrayList<String>();
values.add("Lisa");
values.add("Kevin");
values.add("Roger");
for(String value : values) {
  System.out.print(value + ", ");
}
Этот код скомпилирует и выведет те же значения:

Lisa, Kevin, Roger,
Когда вы видите for-eachпетлю на экзамене, убедитесь, что правая сторона представляет собой массив или Iterableобъект, а левая сторона имеет соответствующий тип. Например, два следующих примера не будут компилироваться.
Почему следующее не скомпилируется?

String names = "Lisa";
for(String name : names) {   // DOES NOT COMPILE
  System.out.print(name + " ");
}
В этом примере String namesон не является массивом и не реализует его java.lang.Iterable, поэтому компилятор сгенерирует исключение, поскольку он не знает, как выполнять итерацию по String.
Почему следующее не скомпилируется?

String[] names = new String[3];
for(int name : names) {  // DOES NOT COMPILE  
System.out.print(name + " ");
}
Эта код не будет скомпилирован, потому что левая часть for-eachоператора не определяет экземпляр String. Обратите внимание, что в этом последнем примере массив инициализируется тремя nullзначениями указателя. Само по себе это не приведет к тому, что код не скомпилируется, поскольку исправленный цикл будет выводиться только nullтри раза.
Сравнение для и для каждого цикла
Так как оба используют одно forи for-eachто же ключевое слово, вам может быть интересно, как они связаны. Хотя это обсуждение выходит за рамки экзамена, давайте for-eachуделим forнемного времени тому, как компилятор преобразует циклы в циклы.
Когда он for-eachбыл представлен в Java 5, он был добавлен как усовершенствование во время компиляции. Это означает, что Java фактически преобразует for-eachцикл в стандартный forцикл во время компиляции. Например, если предположить, что namesэто массив, String[]как мы видели в первом примере, следующие два цикла эквивалентны:
for(String name : names) { 
 System.out.print(name + ", ");
}
for(int i=0; i < names.length; i++) {  
String name = names[i];  
System.out.print(name + ", ");
}
Для объектов, которые наследуются java.lang.Iterable, существует другое, но похожее преобразование. Например, предположим, что valuesэто экземпляр List<Integer>, как мы видели во втором примере, следующие два цикла эквивалентны:



for(int value : values) {  
System.out.print(value + ", ");
}
for(java.util.Iterator<Integer> i = values.iterator(); i.hasNext(); ) {
  int value = i.next(); 
 System.out.print(value + ", ");
}
Обратите внимание, что во второй версии нет updateоператора, так как он не требуется при использовании java.util.Iteratorкласса.
Возможно, вы заметили, что в предыдущих for-eachпримерах в конце списка была напечатана дополнительная запятая:

Lisa, Kevin, Roger,
Пока for-eachзаявление удобно для работы со списками во многих случаях делает доступ скрыть к переменному циклу итератора. Если бы мы хотели печатать только запятую между именами, мы могли бы преобразовать пример в стандартный forцикл, как в следующем примере:

java.util.List<String> names = new java.util.ArrayList<String>();
names.add("Lisa");
names.add("Kevin");
names.add("Roger");
for(int i=0; i<names.size(); i++) { 
 String name = names.get(i);
  if(i>0) {  
  System.out.print(", ");
  }  
  System.out.print(name);
}
Этот пример кода выведет следующее:

Lisa, Kevin, Roger
Также обычно используют стандартный forцикл над for-eachциклом при сравнении нескольких элементов в цикле за одну итерацию, как в следующем примере. Обратите внимание, что мы пропускаем выполнение первого цикла, поскольку value[-1]оно не определено и выдает IndexOutOfBoundsExceptionошибку.

int[] values = new int[3];
values[0] = 10;
values[1] = new Integer(5);
values[2] = 15;
for(int i=1; i<values.length; i++) { 
 System.out.print(values[i]-values[i-1]);
}
Этот пример кода выведет следующее:

-5, 10,
Несмотря на эти примеры, расширенные for-eachциклы весьма полезны в Java в различных обстоятельствах. Однако, как разработчик, вы всегда можете вернуться к стандартному forциклу, если вам нужен точный контроль.
